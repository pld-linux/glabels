diff -urN aa/glabels-1.93.1/po/POTFILES.in glabels-1.93.1/po/POTFILES.in
--- aa/glabels-1.93.1/po/POTFILES.in	2003-12-14 07:04:59.000000000 +0100
+++ glabels-1.93.1/po/POTFILES.in	2003-12-28 23:24:52.434158696 +0100
@@ -149,8 +149,8 @@
 src/mygal/e-colors.c
 src/mygal/e-colors.h
 src/mygal/e-util.h
-src/mygal/gtk-combo-box.c
-src/mygal/gtk-combo-box.h
+src/mygal/mygal-combo-box.c
+src/mygal/mygal-combo-box.h
 src/mygal/widget-color-combo.c
 src/mygal/widget-color-combo.h
 data/paper-sizes.xml
diff -urN aa/glabels-1.93.1/src/Makefile.am glabels-1.93.1/src/Makefile.am
--- aa/glabels-1.93.1/src/Makefile.am	2003-12-06 03:35:56.000000000 +0100
+++ glabels-1.93.1/src/Makefile.am	2003-12-28 23:26:16.952309984 +0100
@@ -19,12 +19,7 @@
 	-DLIBDIR=\""$(libdir)"\"                        	\
 	-DGLABELS_LOCALEDIR=\""$(datadir)/locale"\" 		\
 	-DGLABELS_UI_DIR=\""$(datadir)/glabels/ui/"\" 		\
-	-DGLABELS_GLADE_DIR=\""$(datadir)/glabels/glade/"\"	\
-	-DG_DISABLE_DEPRECATED					\
-	-DGDK_DISABLE_DEPRECATED				\
-	-DGTK_DISABLE_DEPRECATED				\
-	-DGDK_PIXBUF_DISABLE_DEPRECATED				\
-	-DGNOME_DISABLE_DEPRECATED			
+	-DGLABELS_GLADE_DIR=\""$(datadir)/glabels/glade/"\"
 
 glabels_LDFLAGS = -export-dynamic
 
diff -urN aa/glabels-1.93.1/src/mygal/Makefile.am glabels-1.93.1/src/mygal/Makefile.am
--- aa/glabels-1.93.1/src/mygal/Makefile.am	2003-07-27 06:07:19.000000000 +0200
+++ glabels-1.93.1/src/mygal/Makefile.am	2003-12-28 23:23:37.195596696 +0100
@@ -1,10 +1,5 @@
 INCLUDES = \
-	$(GLABELS_CFLAGS) 				\
-	-DG_DISABLE_DEPRECATED				\
-	-DGDK_DISABLE_DEPRECATED			\
-	-DGTK_DISABLE_DEPRECATED			\
-	-DGDK_PIXBUF_DISABLE_DEPRECATED			\
-	-DGNOME_DISABLE_DEPRECATED			
+	$(GLABELS_CFLAGS)
 
 noinst_LTLIBRARIES = libmygal.la
 
@@ -14,8 +9,8 @@
 	e-util.h			\
 	e-colors.c			\
 	e-colors.h			\
-	gtk-combo-box.c			\
-	gtk-combo-box.h			\
+	mygal-combo-box.c			\
+	mygal-combo-box.h			\
 	color-palette.c			\
 	color-palette.h			\
 	color-group.c			\
diff -urN aa/glabels-1.93.1/src/mygal/mygal-combo-box.c glabels-1.93.1/src/mygal/mygal-combo-box.c
--- aa/glabels-1.93.1/src/mygal/mygal-combo-box.c	1970-01-01 01:00:00.000000000 +0100
+++ glabels-1.93.1/src/mygal/mygal-combo-box.c	2003-12-28 23:21:51.273699272 +0100
@@ -0,0 +1,838 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+/*
+ * mygal-combo-box.c - a customizable combobox
+ * Copyright 2000, 2001, Ximian, Inc.
+ *
+ * Authors:
+ *   Miguel de Icaza (miguel@gnu.org)
+ *   Adrian E Feiguin (feiguin@ifir.edu.ar)
+ *   Paolo Molnaro (lupus@debian.org).
+ *   Jon K Hellan (hellan@acm.org)
+ *
+ * Modified for gLabels by:
+ *   Jim Evins <evins@snaught.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License, version 2, as published by the Free Software Foundation.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ */
+
+#include <config.h>
+#include <gtk/gtkhbox.h>
+#include <gtk/gtktogglebutton.h>
+#include <gtk/gtkarrow.h>
+#include <gtk/gtkeventbox.h>
+#include <gtk/gtkmain.h>
+#include <gtk/gtksignal.h>
+#include <gtk/gtkwindow.h>
+#include <gtk/gtkframe.h>
+#include <gtk/gtkvbox.h>
+#include <gtk/gtktearoffmenuitem.h>
+#include <gdk/gdkkeysyms.h>
+#include "mygal-combo-box.h"
+#include "e-util.h"
+
+#define PARENT_TYPE GTK_TYPE_HBOX
+static GObjectClass *mygal_combo_box_parent_class;
+
+static int gtk_combo_toggle_pressed (GtkToggleButton *tbutton,
+				     MygalComboBox *combo_box);
+static void gtk_combo_popup_tear_off (MygalComboBox *combo,
+				      gboolean set_position);
+static void gtk_combo_set_tearoff_state (MygalComboBox *combo,
+					 gboolean torn_off);
+static void gtk_combo_popup_reparent (GtkWidget *popup, GtkWidget *new_parent, 
+				      gboolean unrealize);
+static gboolean cb_popup_delete (GtkWidget *w, GdkEventAny *event,
+			     MygalComboBox *combo);
+static void gtk_combo_tearoff_bg_copy (MygalComboBox *combo);
+
+enum {
+	POP_DOWN_WIDGET,
+	POP_DOWN_DONE,
+	PRE_POP_DOWN,
+	POST_POP_HIDE,
+	LAST_SIGNAL
+};
+
+static guint mygal_combo_box_signals [LAST_SIGNAL] = { 0, };
+
+struct _MygalComboBoxPrivate {
+	GtkWidget *pop_down_widget;
+	GtkWidget *display_widget;
+
+	/*
+	 * Internal widgets used to implement the ComboBox
+	 */
+	GtkWidget *frame;
+	GtkWidget *arrow_button;
+
+	GtkWidget *toplevel;	/* Popup's toplevel when not torn off */
+	GtkWidget *tearoff_window; /* Popup's toplevel when torn off */
+	guint torn_off;
+	
+	GtkWidget *tearable;	/* The tearoff "button" */
+	GtkWidget *popup;	/* Popup */
+
+	/*
+	 * Closure for invoking the callbacks above
+	 */
+	void *closure;
+};
+
+static void
+mygal_combo_box_finalize (GObject *object)
+{
+	MygalComboBox *combo_box = MYGAL_COMBO_BOX (object);
+
+	g_free (combo_box->priv);
+
+	mygal_combo_box_parent_class->finalize (object);
+}
+
+static void
+mygal_combo_box_destroy (GtkObject *object)
+{
+	GtkObjectClass *klass = (GtkObjectClass *)mygal_combo_box_parent_class;
+	MygalComboBox *combo_box = MYGAL_COMBO_BOX (object);
+
+	if (combo_box->priv->toplevel) {
+		gtk_object_destroy (GTK_OBJECT (combo_box->priv->toplevel));
+		combo_box->priv->toplevel = NULL;
+	}
+
+	if (combo_box->priv->tearoff_window) {
+		gtk_object_destroy (GTK_OBJECT (combo_box->priv->tearoff_window));
+		combo_box->priv->tearoff_window = NULL;
+	}
+
+	if (klass->destroy)
+                klass->destroy (object);
+}
+
+static gboolean
+mygal_combo_box_mnemonic_activate (GtkWidget *w, gboolean group_cycling)
+{
+	MygalComboBox *combo_box = MYGAL_COMBO_BOX (w);
+	gtk_toggle_button_set_active (
+		GTK_TOGGLE_BUTTON (combo_box->priv->arrow_button), TRUE);
+	return TRUE;
+}
+
+static void
+mygal_combo_box_class_init (GObjectClass *object_class)
+{
+	GtkWidgetClass *widget_class = (GtkWidgetClass *)object_class;
+	mygal_combo_box_parent_class = g_type_class_peek_parent (object_class);
+
+	object_class->finalize = mygal_combo_box_finalize;
+	widget_class->mnemonic_activate = mygal_combo_box_mnemonic_activate;
+	((GtkObjectClass *)object_class)->destroy = mygal_combo_box_destroy;
+
+	mygal_combo_box_signals [POP_DOWN_WIDGET] = g_signal_new (
+		"pop_down_widget",
+		G_OBJECT_CLASS_TYPE (object_class),
+		G_SIGNAL_RUN_LAST,
+		G_STRUCT_OFFSET (MygalComboBoxClass, pop_down_widget),
+		NULL, NULL,
+		e_marshal_POINTER__NONE,
+		G_TYPE_POINTER, 0, G_TYPE_NONE);
+
+	mygal_combo_box_signals [POP_DOWN_DONE] = g_signal_new (
+		"pop_down_done",
+		G_OBJECT_CLASS_TYPE (object_class),
+		G_SIGNAL_RUN_LAST,
+		G_STRUCT_OFFSET (MygalComboBoxClass, pop_down_done),
+		NULL, NULL,
+		e_marshal_BOOLEAN__OBJECT,
+		G_TYPE_BOOLEAN, 1, G_TYPE_OBJECT);
+
+	mygal_combo_box_signals [PRE_POP_DOWN] = g_signal_new (
+		"pre_pop_down",
+		G_OBJECT_CLASS_TYPE (object_class),
+		G_SIGNAL_RUN_LAST,
+		G_STRUCT_OFFSET (MygalComboBoxClass, pre_pop_down),
+		NULL, NULL,
+		e_marshal_NONE__NONE,
+		G_TYPE_NONE, 0);
+
+	mygal_combo_box_signals [POST_POP_HIDE] = g_signal_new (
+		"post_pop_hide",
+		G_OBJECT_CLASS_TYPE (object_class),
+		G_SIGNAL_RUN_LAST,
+		G_STRUCT_OFFSET (MygalComboBoxClass, post_pop_hide),
+		NULL, NULL,
+		e_marshal_NONE__NONE,
+		G_TYPE_NONE, 0);
+}
+
+static void
+deactivate_arrow (MygalComboBox *combo_box)
+{
+	GtkToggleButton *arrow;
+
+	arrow = GTK_TOGGLE_BUTTON (combo_box->priv->arrow_button);
+	g_signal_handlers_block_matched (arrow,
+					 G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA,
+					 0, 0, NULL,
+					 gtk_combo_toggle_pressed, combo_box);
+
+	gtk_toggle_button_set_active (arrow, FALSE);
+	
+       	g_signal_handlers_unblock_matched (arrow,
+					   G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA,
+					   0, 0, NULL,
+					   gtk_combo_toggle_pressed, combo_box);
+}
+
+/**
+ * mygal_combo_box_popup_hide_unconditional
+ * @combo_box:  Combo box
+ *
+ * Hide popup, whether or not it is torn off.
+ */
+static void
+mygal_combo_box_popup_hide_unconditional (MygalComboBox *combo_box)
+{
+	gboolean popup_info_destroyed = FALSE;
+
+	g_return_if_fail (combo_box != NULL);
+	g_return_if_fail (GTK_IS_COMBO_BOX (combo_box));
+
+	gtk_widget_hide (combo_box->priv->toplevel);
+	gtk_widget_hide (combo_box->priv->popup);
+	if (combo_box->priv->torn_off) {
+		GTK_TEAROFF_MENU_ITEM (combo_box->priv->tearable)->torn_off
+			= FALSE;
+		gtk_combo_set_tearoff_state (combo_box, FALSE);
+	}
+	
+	gtk_grab_remove (combo_box->priv->toplevel);
+	gdk_pointer_ungrab (GDK_CURRENT_TIME);
+		
+	g_object_ref (combo_box->priv->pop_down_widget);
+	g_signal_emit (combo_box,
+		       mygal_combo_box_signals [POP_DOWN_DONE], 0,
+		       combo_box->priv->pop_down_widget, &popup_info_destroyed);
+
+	if (popup_info_destroyed){
+		gtk_container_remove (
+			GTK_CONTAINER (combo_box->priv->frame),
+			combo_box->priv->pop_down_widget);
+		combo_box->priv->pop_down_widget = NULL;
+	}
+	g_object_unref (combo_box->priv->pop_down_widget);
+	deactivate_arrow (combo_box);
+
+	g_signal_emit (combo_box, mygal_combo_box_signals [POST_POP_HIDE], 0);
+}
+
+/**
+ * mygal_combo_box_popup_hide:
+ * @combo_box:  Combo box
+ *
+ * Hide popup, but not when it is torn off.
+ * This is the external interface - for subclasses and apps which expect a
+ * regular combo which doesn't do tearoffs.
+ */
+void
+mygal_combo_box_popup_hide (MygalComboBox *combo_box)
+{
+	if (!combo_box->priv->torn_off)
+		mygal_combo_box_popup_hide_unconditional (combo_box);
+	else if (GTK_WIDGET_VISIBLE (combo_box->priv->toplevel)) {
+		/* Both popup and tearoff window present. Get rid of just
+                   the popup shell. */
+		gtk_combo_popup_tear_off (combo_box, FALSE);
+		deactivate_arrow (combo_box);
+	}		 
+}
+
+/*
+ * Find best location for displaying
+ */
+void
+mygal_combo_box_get_pos (MygalComboBox *combo_box, int *x, int *y)
+{
+	GtkWidget *wcombo = GTK_WIDGET (combo_box);
+	int ph, pw;
+
+	gdk_window_get_origin (wcombo->window, x, y);
+	*y += wcombo->allocation.height + wcombo->allocation.y;
+	*x += wcombo->allocation.x;
+
+	ph = combo_box->priv->popup->allocation.height;
+	pw = combo_box->priv->popup->allocation.width;
+
+	if ((*y + ph) > gdk_screen_height ())
+		*y = gdk_screen_height () - ph;
+
+	if ((*x + pw) > gdk_screen_width ())
+		*x = gdk_screen_width () - pw;
+}
+
+static void
+mygal_combo_box_popup_display (MygalComboBox *combo_box)
+{
+	int x, y;
+
+	g_return_if_fail (combo_box != NULL);
+	g_return_if_fail (GTK_IS_COMBO_BOX (combo_box));
+	
+	/*
+	 * If we have no widget to display on the popdown,
+	 * create it
+	 */
+	if (!combo_box->priv->pop_down_widget){
+		GtkWidget *pw = NULL;
+
+		g_signal_emit (combo_box,
+			       mygal_combo_box_signals [POP_DOWN_WIDGET], 0, &pw);
+		g_assert (pw != NULL);
+		combo_box->priv->pop_down_widget = pw;
+		gtk_container_add (GTK_CONTAINER (combo_box->priv->frame), pw);
+	}
+
+	g_signal_emit (combo_box, mygal_combo_box_signals [PRE_POP_DOWN], 0);
+	
+	if (combo_box->priv->torn_off) {
+		/* To give the illusion that tearoff still displays the
+		 * popup, we copy the image in the popup window to the
+		 * background. Thus, it won't be blank after reparenting */
+		gtk_combo_tearoff_bg_copy (combo_box);
+
+		/* We force an unrealize here so that we don't trigger
+		 * redrawing/ clearing code - we just want to reveal our
+		 * backing pixmap.
+		 */
+		gtk_combo_popup_reparent (combo_box->priv->popup,
+					  combo_box->priv->toplevel, TRUE);
+	}
+
+	mygal_combo_box_get_pos (combo_box, &x, &y);
+	
+	gtk_widget_set_uposition (combo_box->priv->toplevel, x, y);
+	gtk_widget_realize (combo_box->priv->popup);
+	gtk_widget_show (combo_box->priv->popup);
+	gtk_widget_realize (combo_box->priv->toplevel);
+	gtk_widget_show (combo_box->priv->toplevel);
+	
+	gtk_grab_add (combo_box->priv->toplevel);
+	gdk_pointer_grab (combo_box->priv->toplevel->window, TRUE,
+			  GDK_BUTTON_PRESS_MASK |
+			  GDK_BUTTON_RELEASE_MASK |
+			  GDK_POINTER_MOTION_MASK,
+			  NULL, NULL, GDK_CURRENT_TIME);
+}
+
+static int
+gtk_combo_toggle_pressed (GtkToggleButton *tbutton, MygalComboBox *combo_box)
+{
+	if (tbutton->active)
+		mygal_combo_box_popup_display (combo_box);
+	else
+		mygal_combo_box_popup_hide_unconditional (combo_box);
+
+	return TRUE;
+}
+
+static  gint
+mygal_combo_box_button_press (GtkWidget *widget, GdkEventButton *event, MygalComboBox *combo_box)
+{
+	GtkWidget *child;
+
+	child = gtk_get_event_widget ((GdkEvent *) event);
+	if (child != widget){
+		while (child){
+			if (child == widget)
+				return FALSE;
+			child = child->parent;
+		}
+	}
+
+	mygal_combo_box_popup_hide (combo_box);
+	return TRUE;
+}
+
+/**
+ * mygal_combo_box_key_press
+ * @widget:     Widget
+ * @event:      Event
+ * @combo_box:  Combo box
+ *
+ * Key press handler which dismisses popup on escape.
+ * Popup is dismissed whether or not popup is torn off.
+ */
+static  gint
+mygal_combo_box_key_press (GtkWidget *widget, GdkEventKey *event,
+			 MygalComboBox *combo_box)
+{
+	if (event->keyval == GDK_Escape) {
+		mygal_combo_box_popup_hide_unconditional (combo_box);
+		return TRUE;
+	} else
+		return FALSE;
+}
+
+static void
+cb_state_change (GtkWidget *widget, GtkStateType old_state, MygalComboBox *combo_box)
+{
+	GtkStateType const new_state = GTK_WIDGET_STATE(widget);
+	gtk_widget_set_state (combo_box->priv->display_widget, new_state);
+}
+
+static void
+mygal_combo_box_init (MygalComboBox *combo_box)
+{
+	GtkWidget *arrow;
+	GdkCursor *cursor;
+
+	combo_box->priv = g_new0 (MygalComboBoxPrivate, 1);
+
+	/*
+	 * Create the arrow
+	 */
+	combo_box->priv->arrow_button = gtk_toggle_button_new ();
+	gtk_button_set_relief (GTK_BUTTON (combo_box->priv->arrow_button), GTK_RELIEF_NONE);
+	GTK_WIDGET_UNSET_FLAGS (combo_box->priv->arrow_button, GTK_CAN_FOCUS);
+
+	arrow = gtk_arrow_new (GTK_ARROW_DOWN, GTK_SHADOW_IN);
+	gtk_container_add (GTK_CONTAINER (combo_box->priv->arrow_button), arrow);
+	gtk_box_pack_end (GTK_BOX (combo_box), combo_box->priv->arrow_button, FALSE, FALSE, 0);
+	g_signal_connect (combo_box->priv->arrow_button, "toggled",
+			  G_CALLBACK (gtk_combo_toggle_pressed), combo_box);
+	gtk_widget_show_all (combo_box->priv->arrow_button);
+
+	/*
+	 * prelight the display widget when mousing over the arrow.
+	 */
+	g_signal_connect (combo_box->priv->arrow_button, "state-changed",
+			  G_CALLBACK (cb_state_change), combo_box);
+
+	/*
+	 * The pop-down container
+	 */
+
+	combo_box->priv->toplevel = gtk_window_new (GTK_WINDOW_POPUP);
+	gtk_widget_ref (combo_box->priv->toplevel);
+	gtk_object_sink (GTK_OBJECT (combo_box->priv->toplevel));
+	gtk_window_set_policy (GTK_WINDOW (combo_box->priv->toplevel),
+			       FALSE, TRUE, FALSE);
+
+	combo_box->priv->popup = gtk_event_box_new ();
+	gtk_container_add (GTK_CONTAINER (combo_box->priv->toplevel),
+			   combo_box->priv->popup);
+	gtk_widget_show (combo_box->priv->popup);
+
+	gtk_widget_realize (combo_box->priv->popup);
+	cursor = gdk_cursor_new (GDK_TOP_LEFT_ARROW);
+	gdk_window_set_cursor (combo_box->priv->popup->window, cursor);
+	gdk_cursor_unref (cursor);
+
+	combo_box->priv->torn_off = FALSE;
+	combo_box->priv->tearoff_window = NULL;
+	
+	combo_box->priv->frame = gtk_frame_new (NULL);
+	gtk_container_add (GTK_CONTAINER (combo_box->priv->popup),
+			   combo_box->priv->frame);
+	gtk_frame_set_shadow_type (GTK_FRAME (combo_box->priv->frame), GTK_SHADOW_OUT);
+
+	g_signal_connect (combo_box->priv->toplevel, "button_press_event",
+			  G_CALLBACK (mygal_combo_box_button_press), combo_box);
+	g_signal_connect (combo_box->priv->toplevel, "key_press_event",
+			  G_CALLBACK (mygal_combo_box_key_press), combo_box);
+}
+
+E_MAKE_TYPE (mygal_combo_box,
+	     "MygalComboBox",
+	     MygalComboBox,
+	     mygal_combo_box_class_init,
+	     mygal_combo_box_init,
+	     PARENT_TYPE)
+
+/**
+ * mygal_combo_box_set_display:
+ * @combo_box: the Combo Box to modify
+ * @display_widget: The widget to be displayed
+
+ * Sets the displayed widget for the @combo_box to be @display_widget
+ */
+void
+mygal_combo_box_set_display (MygalComboBox *combo_box, GtkWidget *display_widget)
+{
+	g_return_if_fail (combo_box != NULL);
+	g_return_if_fail (GTK_IS_COMBO_BOX (combo_box));
+	g_return_if_fail (display_widget != NULL);
+	g_return_if_fail (GTK_IS_WIDGET (display_widget));
+
+	if (combo_box->priv->display_widget &&
+	    combo_box->priv->display_widget != display_widget)
+		gtk_container_remove (GTK_CONTAINER (combo_box),
+				      combo_box->priv->display_widget);
+
+	combo_box->priv->display_widget = display_widget;
+
+	gtk_box_pack_start (GTK_BOX (combo_box), display_widget, TRUE, TRUE, 0);
+}
+
+static gboolean
+cb_tearable_enter_leave (GtkWidget *w, GdkEventCrossing *event, gpointer data)
+{
+	gboolean const flag = GPOINTER_TO_INT(data);
+	gtk_widget_set_state (w, flag ? GTK_STATE_PRELIGHT : GTK_STATE_NORMAL);
+	return FALSE;
+}
+
+/**
+ * gtk_combo_popup_tear_off
+ * @combo:         Combo box
+ * @set_position:  Set to position of popup shell if true
+ *
+ * Tear off the popup
+ *
+ * FIXME:
+ * Gtk popup menus are toplevel windows, not dialogs. I think this is wrong,
+ * and make the popups dialogs. But may be there should be a way to make
+ * them toplevel. We can do this after creating:
+ * GTK_WINDOW (tearoff)->type = GTK_WINDOW_TOPLEVEL;
+ */
+static void
+gtk_combo_popup_tear_off (MygalComboBox *combo, gboolean set_position)
+{
+	int x, y;
+	
+	if (!combo->priv->tearoff_window) {
+		GtkWidget *tearoff;
+		gchar *title;
+		
+		/* FIXME: made this a toplevel, not a dialog ! */
+		tearoff = gtk_window_new (GTK_WINDOW_TOPLEVEL);
+		gtk_widget_ref (tearoff);
+		gtk_object_sink (GTK_OBJECT (tearoff));
+		combo->priv->tearoff_window = tearoff;
+		gtk_widget_set_app_paintable (tearoff, TRUE);
+		g_signal_connect (tearoff, "key_press_event",
+				  G_CALLBACK (mygal_combo_box_key_press),
+				  combo);
+		gtk_widget_realize (tearoff);
+		title = g_object_get_data (G_OBJECT (combo),
+					   "gtk-combo-title");
+		if (title)
+			gdk_window_set_title (tearoff->window, title);
+		gtk_window_set_policy (GTK_WINDOW (tearoff),
+				       FALSE, TRUE, FALSE);
+		gtk_window_set_transient_for 
+			(GTK_WINDOW (tearoff),
+			 GTK_WINDOW (gtk_widget_get_toplevel
+				     GTK_WIDGET (combo)));
+	}
+
+	if (GTK_WIDGET_VISIBLE (combo->priv->popup)) {
+		gtk_widget_hide (combo->priv->toplevel);
+		
+		gtk_grab_remove (combo->priv->toplevel);
+		gdk_pointer_ungrab (GDK_CURRENT_TIME);
+	}
+
+	gtk_combo_popup_reparent (combo->priv->popup,
+				  combo->priv->tearoff_window, FALSE);
+
+	/* It may have got confused about size */
+	gtk_widget_queue_resize (GTK_WIDGET (combo->priv->popup));
+
+	if (set_position) {
+		mygal_combo_box_get_pos (combo, &x, &y);
+		gtk_widget_set_uposition (combo->priv->tearoff_window, x, y);
+	}
+	gtk_widget_show (GTK_WIDGET (combo->priv->popup));
+	gtk_widget_show (combo->priv->tearoff_window);
+		
+}
+
+/**
+ * gtk_combo_set_tearoff_state
+ * @combo_box:  Combo box
+ * @torn_off:   TRUE: Tear off. FALSE: Pop down and reattach
+ *
+ * Set the tearoff state of the popup
+ *
+ * Compare with gtk_menu_set_tearoff_state in gtk/gtkmenu.c
+ */
+static void       
+gtk_combo_set_tearoff_state (MygalComboBox *combo,
+			     gboolean  torn_off)
+{
+	g_return_if_fail (combo != NULL);
+	g_return_if_fail (GTK_IS_COMBO_BOX (combo));
+	
+	if (combo->priv->torn_off != torn_off) {
+		combo->priv->torn_off = torn_off;
+		
+		if (combo->priv->torn_off) {
+			gtk_combo_popup_tear_off (combo, TRUE);
+			deactivate_arrow (combo);
+		} else {
+			gtk_widget_hide (combo->priv->tearoff_window);
+			gtk_combo_popup_reparent (combo->priv->popup,
+						  combo->priv->toplevel,
+						  FALSE);
+		}
+	}
+}
+
+/**
+ * gtk_combo_tearoff_bg_copy
+ * @combo_box:  Combo box
+ *
+ * Copy popup window image to the tearoff window.
+ */
+static void
+gtk_combo_tearoff_bg_copy (MygalComboBox *combo)
+{
+	GdkPixmap *pixmap;
+	GdkGC *gc;
+	GdkGCValues gc_values;
+
+	GtkWidget *widget = combo->priv->popup;
+
+	if (combo->priv->torn_off) {
+		gc_values.subwindow_mode = GDK_INCLUDE_INFERIORS;
+		gc = gdk_gc_new_with_values (widget->window,
+					     &gc_values, GDK_GC_SUBWINDOW);
+      
+		pixmap = gdk_pixmap_new (widget->window,
+					 widget->allocation.width,
+					 widget->allocation.height,
+					 -1);
+
+		gdk_draw_drawable (pixmap, gc,
+				 widget->window,
+				 0, 0, 0, 0, -1, -1);
+		gdk_gc_unref (gc);
+      
+		gtk_widget_set_usize (combo->priv->tearoff_window,
+				      widget->allocation.width,
+				      widget->allocation.height);
+      
+		gdk_window_set_back_pixmap
+			(combo->priv->tearoff_window->window, pixmap, FALSE);
+		gdk_drawable_unref (pixmap);
+	}
+}
+
+/**
+ * gtk_combo_popup_reparent
+ * @popup:       Popup
+ * @new_parent:  New parent
+ * @unrealize:   Unrealize popup if TRUE.
+ *
+ * Reparent the popup, taking care of the refcounting
+ *
+ * Compare with gtk_menu_reparent in gtk/gtkmenu.c
+ */
+static void 
+gtk_combo_popup_reparent (GtkWidget *popup, 
+			  GtkWidget *new_parent, 
+			  gboolean unrealize)
+{
+	GtkObject *object = GTK_OBJECT (popup);
+	gboolean was_floating = GTK_OBJECT_FLOATING (object);
+
+	g_object_ref (object);
+	gtk_object_sink (object);
+
+	if (unrealize) {
+		g_object_ref (object);
+		gtk_container_remove (GTK_CONTAINER (popup->parent), popup);
+		gtk_container_add (GTK_CONTAINER (new_parent), popup);
+		g_object_unref (object);
+	}
+	else
+		gtk_widget_reparent (GTK_WIDGET (popup), new_parent);
+	gtk_widget_set_usize (new_parent, -1, -1);
+  
+	if (was_floating)
+		GTK_OBJECT_SET_FLAGS (object, GTK_FLOATING);
+	else
+		g_object_unref (object);
+}
+
+/**
+ * cb_tearable_button_release
+ * @w:      Widget
+ * @event:  Event
+ * @combo:  Combo box
+ *
+ * Toggle tearoff state.
+ */
+static gboolean
+cb_tearable_button_release (GtkWidget *w, GdkEventButton *event,
+			    MygalComboBox *combo)
+{
+	GtkTearoffMenuItem *tearable;
+	
+	g_return_val_if_fail (w != NULL, FALSE);
+	g_return_val_if_fail (GTK_IS_TEAROFF_MENU_ITEM (w), FALSE);
+
+	tearable = GTK_TEAROFF_MENU_ITEM (w);
+	tearable->torn_off = !tearable->torn_off;
+
+	if (!combo->priv->torn_off) {
+		gboolean need_connect;
+			
+		need_connect = (!combo->priv->tearoff_window);
+		gtk_combo_set_tearoff_state (combo, TRUE);
+		if (need_connect)
+			g_signal_connect (combo->priv->tearoff_window,  
+					  "delete_event",
+					  G_CALLBACK (cb_popup_delete),
+					  combo);
+	} else
+		mygal_combo_box_popup_hide_unconditional (combo);
+	
+	return TRUE;
+}
+
+static gboolean
+cb_popup_delete (GtkWidget *w, GdkEventAny *event, MygalComboBox *combo)
+{
+	mygal_combo_box_popup_hide_unconditional (combo);
+	return TRUE;
+}
+
+void
+mygal_combo_box_construct (MygalComboBox *combo_box, GtkWidget *display_widget, GtkWidget *pop_down_widget)
+{
+	GtkWidget *tearable;
+	GtkWidget *vbox;
+
+	g_return_if_fail (combo_box != NULL);
+	g_return_if_fail (GTK_IS_COMBO_BOX (combo_box));
+	g_return_if_fail (display_widget  != NULL);
+	g_return_if_fail (GTK_IS_WIDGET (display_widget));
+
+	GTK_BOX (combo_box)->spacing = 0;
+	GTK_BOX (combo_box)->homogeneous = FALSE;
+
+	combo_box->priv->pop_down_widget = pop_down_widget;
+	combo_box->priv->display_widget = NULL;
+
+	vbox = gtk_vbox_new (FALSE, 5);
+	tearable = gtk_tearoff_menu_item_new ();
+	g_signal_connect (tearable, "enter-notify-event",
+			  G_CALLBACK (cb_tearable_enter_leave),
+			  GINT_TO_POINTER (TRUE));
+	g_signal_connect (tearable, "leave-notify-event",
+			  G_CALLBACK (cb_tearable_enter_leave),
+			  GINT_TO_POINTER (FALSE));
+	g_signal_connect (tearable, "button-release-event",
+			  G_CALLBACK (cb_tearable_button_release),
+			  (gpointer) combo_box);
+	gtk_box_pack_start (GTK_BOX (vbox), tearable, FALSE, FALSE, 0);
+	gtk_box_pack_start (GTK_BOX (vbox), pop_down_widget, TRUE, TRUE, 0);
+	combo_box->priv->tearable = tearable;
+
+	/*
+	 * Finish setup
+	 */
+	mygal_combo_box_set_display (combo_box, display_widget);
+
+	gtk_container_add (GTK_CONTAINER (combo_box->priv->frame), vbox);
+	gtk_widget_show_all (combo_box->priv->frame);
+}
+
+GtkWidget *
+mygal_combo_box_new (GtkWidget *display_widget, GtkWidget *optional_popdown)
+{
+	MygalComboBox *combo_box;
+
+	g_return_val_if_fail (display_widget  != NULL, NULL);
+	g_return_val_if_fail (GTK_IS_WIDGET (display_widget), NULL);
+
+	combo_box = g_object_new (MYGAL_COMBO_BOX_TYPE, NULL);
+	mygal_combo_box_construct (combo_box, display_widget, optional_popdown);
+	return GTK_WIDGET (combo_box);
+}
+
+void
+mygal_combo_box_set_arrow_relief (MygalComboBox *cc, GtkReliefStyle relief)
+{
+	g_return_if_fail (cc != NULL);
+	g_return_if_fail (GTK_IS_COMBO_BOX (cc));
+
+	gtk_button_set_relief (GTK_BUTTON (cc->priv->arrow_button), relief);
+}
+
+/**
+ * mygal_combo_box_set_title
+ * @combo: Combo box
+ * @title: Title
+ *
+ * Set a title to display over the tearoff window.
+ *
+ * FIXME:
+ *
+ * This should really change the title even when the popup is already torn off.
+ * I guess the tearoff window could attach a listener to title change or
+ * something. But I don't think we need the functionality, so I didn't bother
+ * to investigate.
+ */
+void       
+mygal_combo_box_set_title (MygalComboBox *combo,
+			 const gchar *title)
+{
+	g_return_if_fail (combo != NULL);
+	g_return_if_fail (GTK_IS_COMBO_BOX (combo));
+	
+	g_object_set_data_full (G_OBJECT (combo), "gtk-combo-title",
+				g_strdup (title), (GDestroyNotify) g_free);
+}
+
+/**
+ * mygal_combo_box_set_arrow_sensitive
+ * @combo:  Combo box
+ * @sensitive:  Sensitivity value
+ *
+ * Toggle the sensitivity of the arrow button
+ */
+
+void
+mygal_combo_box_set_arrow_sensitive (MygalComboBox *combo,
+				   gboolean sensitive)
+{
+	g_return_if_fail (combo != NULL);
+
+	gtk_widget_set_sensitive (combo->priv->arrow_button, sensitive);
+}
+
+/**
+ * mygal_combo_box_set_tearable:
+ * @combo: Combo box
+ * @tearable: whether to allow the @combo to be tearable
+ *
+ * controls whether the combo box's pop up widget can be torn off.
+ */
+void
+mygal_combo_box_set_tearable (MygalComboBox *combo, gboolean tearable)
+{
+	g_return_if_fail (combo != NULL);
+	g_return_if_fail (GTK_IS_COMBO_BOX (combo));
+
+	if (tearable){
+		gtk_widget_show (combo->priv->tearable);
+	} else {
+		gtk_combo_set_tearoff_state (combo, FALSE);
+		gtk_widget_hide (combo->priv->tearable);
+	}
+}
+
diff -urN aa/glabels-1.93.1/src/mygal/mygal-combo-box.h glabels-1.93.1/src/mygal/mygal-combo-box.h
--- aa/glabels-1.93.1/src/mygal/mygal-combo-box.h	1970-01-01 01:00:00.000000000 +0100
+++ glabels-1.93.1/src/mygal/mygal-combo-box.h	2003-12-28 23:22:19.782365296 +0100
@@ -0,0 +1,95 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+/*
+ * mygal-combo-box.h - a customizable combobox
+ * Copyright 2000, 2001, Ximian, Inc.
+ *
+ * Authors:
+ *   Miguel de Icaza <miguel@ximian.com>
+ *
+ * Modified for gLabels by:
+ *   Jim Evins <evins@snaught.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License, version 2, as published by the Free Software Foundation.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ */
+
+#ifndef _MYGAL_COMBO_BOX_H_
+#define _MYGAL_COMBO_BOX_H_
+
+#include <gtk/gtkhbox.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#define MYGAL_COMBO_BOX_TYPE          (mygal_combo_box_get_type())
+#define MYGAL_COMBO_BOX(obj)	      G_TYPE_CHECK_INSTANCE_CAST (obj, mygal_combo_box_get_type (), MygalComboBox)
+#define MYGAL_COMBO_BOX_CLASS(klass)  G_TYPE_CHECK_CLASS_CAST (klass, mygal_combo_box_get_type (), MygalComboBoxClass)
+#define GTK_IS_COMBO_BOX(obj)         G_TYPE_CHECK_INSTANCE_TYPE (obj, mygal_combo_box_get_type ())
+
+typedef struct _MygalComboBox	     MygalComboBox;
+typedef struct _MygalComboBoxPrivate MygalComboBoxPrivate;
+typedef struct _MygalComboBoxClass   MygalComboBoxClass;
+
+struct _MygalComboBox {
+	GtkHBox hbox;
+	MygalComboBoxPrivate *priv;
+};
+
+struct _MygalComboBoxClass {
+	GtkHBoxClass parent_class;
+
+	GtkWidget *(*pop_down_widget) (MygalComboBox *cbox);
+
+	/*
+	 * invoked when the popup has been hidden, if the signal
+	 * returns TRUE, it means it should be killed from the
+	 */ 
+	gboolean  *(*pop_down_done)   (MygalComboBox *cbox, GtkWidget *);
+
+	/*
+	 * Notification signals.
+	 */
+	void      (*pre_pop_down)     (MygalComboBox *cbox);
+	void      (*post_pop_hide)    (MygalComboBox *cbox);
+};
+
+GtkType    mygal_combo_box_get_type    (void);
+void       mygal_combo_box_construct   (MygalComboBox *combo_box,
+					GtkWidget   *display_widget,
+					GtkWidget   *optional_pop_down_widget);
+void       mygal_combo_box_get_pos     (MygalComboBox *combo_box, int *x, int *y);
+
+GtkWidget *mygal_combo_box_new         (GtkWidget *display_widget,
+					GtkWidget *optional_pop_down_widget);
+void       mygal_combo_box_popup_hide  (MygalComboBox *combo_box);
+
+void       mygal_combo_box_set_display (MygalComboBox *combo_box,
+					GtkWidget *display_widget);
+
+void       mygal_combo_box_set_title   (MygalComboBox *combo,
+					const gchar *title);
+
+void       mygal_combo_box_set_tearable        (MygalComboBox *combo,
+						gboolean tearable);
+void       mygal_combo_box_set_arrow_sensitive (MygalComboBox *combo,
+						gboolean sensitive);
+void       mygal_combo_box_set_arrow_relief    (MygalComboBox *cc,
+						GtkReliefStyle relief);
+#ifdef __cplusplus
+};
+#endif /* __cplusplus */
+
+#endif /* _MYGAL_COMBO_BOX_H_ */
+
diff -urN aa/glabels-1.93.1/src/mygal/widget-color-combo.c glabels-1.93.1/src/mygal/widget-color-combo.c
--- aa/glabels-1.93.1/src/mygal/widget-color-combo.c	2003-12-16 02:08:49.000000000 +0100
+++ glabels-1.93.1/src/mygal/widget-color-combo.c	2003-12-28 23:33:12.067202928 +0100
@@ -47,7 +47,7 @@
 
 static guint color_combo_signals [LAST_SIGNAL] = { 0, };
 
-#define PARENT_TYPE GTK_COMBO_BOX_TYPE
+#define PARENT_TYPE MYGAL_COMBO_BOX_TYPE
 static GObjectClass *color_combo_parent_class;
 
 #define make_color(CC,COL) (((COL) != NULL) ? (COL) : ((CC) ? ((CC)->default_color) : NULL))
@@ -140,7 +140,7 @@
   	g_signal_emit (cc,
 		       color_combo_signals [CHANGED], 0,
 		       color, is_custom, by_user, is_default);
-	gtk_combo_box_popup_hide (GTK_COMBO_BOX (cc));
+	mygal_combo_box_popup_hide (MYGAL_COMBO_BOX (cc));
 }
 
 static void
@@ -165,7 +165,7 @@
 static void
 cb_cust_color_clicked (GtkWidget *widget, ColorCombo *cc)
 {
-	gtk_combo_box_popup_hide (GTK_COMBO_BOX (cc));
+	mygal_combo_box_popup_hide (MYGAL_COMBO_BOX (cc));
 }
 
 /*
@@ -255,11 +255,11 @@
 
 	gtk_widget_show_all (cc->preview_button);
 
-	gtk_combo_box_construct (GTK_COMBO_BOX (cc),
+	mygal_combo_box_construct (MYGAL_COMBO_BOX (cc),
 				 cc->preview_button,
 				 GTK_WIDGET (cc->palette));
 
-	gtk_combo_box_set_tearable (GTK_COMBO_BOX (cc), FALSE);
+	mygal_combo_box_set_tearable (MYGAL_COMBO_BOX (cc), FALSE);
 
 	color = color_palette_get_current_color (cc->palette, NULL);
 	color_combo_set_color_internal (cc, color);
diff -urN aa/glabels-1.93.1/src/mygal/widget-color-combo.h glabels-1.93.1/src/mygal/widget-color-combo.h
--- aa/glabels-1.93.1/src/mygal/widget-color-combo.h	2003-10-08 05:28:31.000000000 +0200
+++ glabels-1.93.1/src/mygal/widget-color-combo.h	2003-12-28 23:18:42.952328472 +0100
@@ -35,13 +35,13 @@
 #define GNUMERIC_WIDGET_COLOR_COMBO_H
 
 #include <gtk/gtkwidget.h>
-#include "gtk-combo-box.h"
+#include "mygal-combo-box.h"
 #include "color-palette.h"
 
 G_BEGIN_DECLS
 
 typedef struct _ColorCombo {
-	GtkComboBox     combo_box;
+	MygalComboBox     combo_box;
 
 	/*
 	 * GtkImage where we display
@@ -57,7 +57,7 @@
 } ColorCombo;
 
 typedef struct {
-	GtkComboBoxClass parent_class;
+	MygalComboBoxClass parent_class;
 
 	/* Signals emited by this widget */
 	void (* color_changed) (ColorCombo *color_combo, GdkColor *color,
diff -urN aa/glabels-1.93.1/src/recent-files/Makefile.am glabels-1.93.1/src/recent-files/Makefile.am
--- aa/glabels-1.93.1/src/recent-files/Makefile.am	2003-10-19 06:10:14.000000000 +0200
+++ glabels-1.93.1/src/recent-files/Makefile.am	2003-12-28 23:27:00.186737352 +0100
@@ -1,10 +1,5 @@
 INCLUDES = \
-	$(GLABELS_CFLAGS) 					\
-	-DG_DISABLE_DEPRECATED					\
-	-DGDK_DISABLE_DEPRECATED				\
-	-DGTK_DISABLE_DEPRECATED				\
-	-DGDK_PIXBUF_DISABLE_DEPRECATED				\
-	-DGNOME_DISABLE_DEPRECATED			
+	$(GLABELS_CFLAGS)
 
 EGG_FILES =				\
         egg-recent-model.c		\
